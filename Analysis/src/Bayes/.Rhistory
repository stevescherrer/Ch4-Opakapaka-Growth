k_tau ~ dgamma(0.01, 0.0001)
tau ~ dgamma(0.01, 0.0001)
}')
sink()
### Model 2
sink(file = file.path(getwd(),'model2upd.bug.txt'), type = 'output')
writeLines('## Model 2
model{
# Loop through individual fish
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}
# Calculate estimated length at tagging
L[i, 1] ~ dnorm(L_Exp[i, 1], tau)
L_Exp[i, 1] <-   Linf[i] *(1.0 - exp(-k[i]*A[i]))
L.pred[i, 1] ~ dnorm(L_Exp[i, 1], tau)
p.value[i, 1] <- step(L.pred[i, 1]- L[i, 1])
Linf[i] ~ dnorm(Linf_mu,  Linf_tau)
k[i] ~ dnorm(k_mu, k_tau) I(0,1)
A[i] ~ dgamma(shape, rate)
}
Linf_std <- sqrt(1/Linf_tau)
k_std <- sqrt(1/k_tau)
var <- 1/tau
k ~ dnorm(k_mu, k_tau) I(0,1)
Linf_mu ~ dnorm(100, 0.0001)
Linf_tau ~ dgamma(0.01, 0.0001)
shape ~ dunif(0, 100)
rate ~ dunif(0, 100)
k_mu ~ dbeta(1, 1)
k_tau ~ dgamma(0.01, 0.0001)
tau ~ dgamma(0.01, 0.0001)
}')
sink()
### Model 3
sink(file = file.path(getwd(),'model3upd.bug.txt'), type = 'output')
writeLines('## Model 3
model{
# Loop through individual fish
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}
# Calculate estimated length at tagging
L[i, 1] ~ dnorm(L_Exp[i, 1], tau)
L_Exp[i, 1] <-   Linf[i] *(1.0 - exp(-k[i]*A[i]))
L.pred[i, 1] ~ dnorm(L_Exp[i, 1], tau)
p.value[i, 1] <- step(L.pred[i, 1]- L[i, 1])
Linf[i] ~ dnorm(Linf_mu,  Linf_tau)
k[i] ~ dnorm(k_mu, k_tau) I(0,1)
A[i] ~ dgamma(shape, rate)
}
Linf_std <- sqrt(1/Linf_tau)
k_std <- sqrt(1/k_tau)
var <- 1/tau
Linf ~ dnorm(Linf_mu,  Linf_tau)
Linf_mu ~ dnorm(100, 0.0001)
Linf_tau ~ dgamma(0.01, 0.0001)
shape ~ dunif(0, 100)
rate ~ dunif(0, 100)
k_mu ~ dbeta(1, 1)
k_tau ~ dgamma(0.01, 0.0001)
tau ~ dgamma(0.01, 0.0001)
}')
sink()
### Model 4
sink(file = file.path(getwd(),'model4upd.bug.txt'), type = 'output')
writeLines('## Model 4
model{
# Loop through individual fish
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}
# Calculate estimated length at tagging
L[i, 1] ~ dnorm(L_Exp[i, 1], tau)
L_Exp[i, 1] <-   Linf[i] *(1.0 - exp(-k[i]*A[i]))
L.pred[i, 1] ~ dnorm(L_Exp[i, 1], tau)
p.value[i, 1] <- step(L.pred[i, 1]- L[i, 1])
Linf[i] ~ dnorm(Linf_mu,  Linf_tau)
k[i] ~ dnorm(k_mu, k_tau) I(0,1)
A[i] ~ dgamma(shape, rate)
}
Linf_std <- sqrt(1/Linf_tau)
k_std <- sqrt(1/k_tau)
var <- 1/tau
k ~ dnorm(k_mu, k_tau) I(0,1)
Linf ~ dnorm(Linf_mu,  Linf_tau)
Linf_mu ~ dnorm(100, 0.0001)
Linf_tau ~ dgamma(0.01, 0.0001)
shape ~ dunif(0, 100)
rate ~ dunif(0, 100)
k_mu ~ dbeta(1, 1)
k_tau ~ dgamma(0.01, 0.0001)
tau ~ dgamma(0.01, 0.0001)
}')
sink()
sink()
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.bug.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50,
bugs.directory = "C:/Users/Weng Lab/Downloads/winbugs143_unrestricted/winbugs14_full_patched/WinBUGS14",
debug = TRUE)
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.bug.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50)
### Model 1
sink(file = file.path(getwd(),'model1upd.txt'), type = 'output')
writeLines('## Model 1
model{
# Loop through individual fish
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}
# Calculate estimated length at tagging
L[i, 1] ~ dnorm(L_Exp[i, 1], tau)
L_Exp[i, 1] <-   Linf[i] *(1.0 - exp(-k[i]*A[i]))
L.pred[i, 1] ~ dnorm(L_Exp[i, 1], tau)
p.value[i, 1] <- step(L.pred[i, 1]- L[i, 1])
Linf[i] ~ dnorm(Linf_mu,  Linf_tau)
k[i] ~ dnorm(k_mu, k_tau) I(0,1)
A[i] ~ dgamma(shape, rate)
}
Linf_std <- sqrt(1/Linf_tau)
k_std <- sqrt(1/k_tau)
var <- 1/tau
Linf_mu ~ dnorm(100, 0.0001)
Linf_tau ~ dgamma(0.01, 0.0001)
shape ~ dunif(0, 100)
rate ~ dunif(0, 100)
k_mu ~ dbeta(1, 1)
k_tau ~ dgamma(0.01, 0.0001)
tau ~ dgamma(0.01, 0.0001)
}')
sink()
inits = function(){
#  list(Linf_mu = c(60, 60*0.5, 60*2), Linf_tau = c(0.03, 0.03*0.5, 0.03*2), shape = c(56, 56*0.05, 56*2), rate = c(21, 21*.05, 21*2), k_mu = c(0.3, 0.3*0.5, 0.3*2), k_tau = c(9121, 9121*0.5, 9121*2), tau = c(0.12, 0.12*0.5, 0.12*2))
list(Linf_mu = 60, Linf_tau = 0.03, shape = 56, rate = 21, k_mu = 0.3, k_tau = 9121, tau = 0.12)
}
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50)
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50,
bugs.directory = "C:/Users/Weng Lab/Downloads/winbugs143_unrestricted/winbugs14_full_patched/WinBUGS14",
debug = TRUE)
K = .3
Linf = rep(80, length(n))
K = rep(80, length(n))
A = rep(3, length(n))
K = rep(.3, length(n))
writeLines('## Model 1
model{
# Loop through individual fish
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}
# Calculate estimated length at tagging
L[i, 1] ~ dnorm(L_Exp[i, 1], tau)
L_Exp[i, 1] <-   Linf[i] *(1.0 - exp(-k[i]*A[i]))
L.pred[i, 1] ~ dnorm(L_Exp[i, 1], tau)
p.value[i, 1] <- step(L.pred[i, 1]- L[i, 1])
Linf[i] ~ dnorm(Linf_mu,  Linf_tau)
k[i] ~ dnorm(k_mu, k_tau) I(0,1)
A[i] ~ dgamma(shape, rate)
}
Linf_std <- sqrt(1/Linf_tau)
k_std <- sqrt(1/k_tau)
var <- 1/tau
Linf_mu ~ dnorm(100, 0.0001)
Linf_tau ~ dgamma(0.01, 0.0001)
shape ~ dunif(0, 100)
rate ~ dunif(0, 100)
k_mu ~ dbeta(1, 1)
k_tau ~ dgamma(0.01, 0.0001)
tau ~ dgamma(0.01, 0.0001)
}')
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}
}
k = rep(0.3, length(n))
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}}
L_EXP = L
L.pred = L
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}}
L_Exp = L
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}}
i
j
L.pred[i,j]
## Removing fish without valid recaptures
dt = as.numeric(dt[valid_recaps, ])
## Preallocating data objects in memory
n = rep(0, length(mark_recapture_data$tag_id))
L = matrix(nrow = length(mark_recapture_data$tag_id), ncol = (max_recaptures + 1), data = NA) # Note that matrix L gets an extra column corrosponding to initial fork length at tagging
dt = matrix(nrow = length(mark_recapture_data$tag_id), ncol = max_recaptures, data = NA) # Note that because dt is the difference in time, therefore it is one column less than L
for(i in 1:length(mark_recapture_data$tag_id)){
## For each individual, we start at the intial length at tagging and work our way up through recaptures
L[i,1] = as.numeric(mark_recapture_data$fork_length_in[i])
## Recapture 1
if(!is.na(mark_recapture_data$recapture_1_fork_length_cm[i])){
## Calculate differece in time and if its greater than 60 days
dt1 = difftime(mark_recapture_data$recapture_1_date[i], mark_recapture_data$tag_date[i], units = 'days') / 365
if(all(!is.na(dt1) & dt1 > 60/365)){
# Updating vector n
n[i] = n[i] + 1
# Getting recorded fork length
L[i, 2] = as.numeric(mark_recapture_data$recapture_1_fork_length_cm[i])
# Calculating time at liberty
dt[i, 1] = as.numeric(dt1)
}
}
### Repeat the above for subsequent recaptures
## Recapture 2
if(!is.na(mark_recapture_data$recapture_2_fork_length_cm[i])){
dt2 = difftime(mark_recapture_data$recapture_2_date[i], mark_recapture_data$tag_date[i], units = 'days') / 36
if(all(!is.na(dt2) & dt2 > 60/365)){
n[i] = 2
L[i, 3] = as.numeric(mark_recapture_data$recapture_2_fork_length_cm[i])
dt[i, 2] = as.numeric(dt2)
}
}
## Recapture 3
if(!is.na(mark_recapture_data$recapture_3_fork_length_cm[i])){
dt3 = difftime(mark_recapture_data$recapture_3_date[i], mark_recapture_data$tag_date[i], units = 'days') / 365
if(all(!is.na(dt3) & dt3 > 60/365)){
n[i] = 3
L[i, 4] = as.numeric(mark_recapture_data$recapture_3_fork_length_cm[i])
dt[i, 3] = as.numeric(dt3)
}
}
if(!is.na(mark_recapture_data$recapture_4_fork_length_cm[i])){
dt4 = difftime(mark_recapture_data$recapture_4_date[i], mark_recapture_data$tag_date[i], units = 'days') / 365
if(all(!is.na(dt4) & dt4 > 60/365)){
n[i] = 4
L[i, 5] = as.numeric(mark_recapture_data$recapture_4_fork_length_cm[i])
dt[i,4] = as.numeric(dt4)
}
}
}
### L and dt matricies need to be adjusted for fish recaptured more than once but for whom one of their recaptures was excluded for being less than our 60 day threshold
## Set up vector indexing which fish to remove after our loop.We will remove fish that have no recaptures after 60 days a liberty.
valid_recaps = rep(TRUE, dim(dt)[1])
## Loop through each fish
for(i in 1:dim(dt)[1]){
# If the first column of NAs does not come after the last column of data or if the whole row isn't NAs
while(!all(is.na(dt[i, ])) && (!max(which(!is.na(dt[i, ]))) < min(which(is.na(dt[i, ]))))){
# We shift all our data after the NA over by one and try again
L[i, (1 + min(which(is.na(dt[i, ])))):ncol(dt)] =  c(L[i, (1 + (min(which(is.na(dt[i, ]))))+ 1):ncol(dt)], NA)
dt[i, min(which(is.na(dt[i, ]))):ncol(dt)] =  c(dt[i, (min(which(is.na(dt[i, ]))) + 1):ncol(dt)], NA)
}
if(all(is.na(dt[i, ]))){
valid_recaps[i] = FALSE
}
}
## Removing fish without valid recaptures
dt = as.numeric(dt[valid_recaps, ])
n = n[valid_recaps]
mark_recap_data = list('n', 'L', 'dt')
dt
L
n
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50,
bugs.directory = "C:/Users/Weng Lab/Downloads/winbugs143_unrestricted/winbugs14_full_patched/WinBUGS14",
debug = TRUE)
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50)
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50, debug = T)
#### Loading Priniciple Dependencies ####
# install.packages('R2OpenBUGS')
library('R2winBUGS')
library(R2WinBUGS)
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50, debug = T,
bugs.directory = "C:/Users/Weng Lab/Downloads/winbugs143_unrestricted/winbugs14_full_patched/WinBUGS14",
debug = TRUE)
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50, debug = T,
bugs.directory = "C:/Users/Weng Lab/Downloads/winbugs143_unrestricted/winbugs14_full_patched/WinBUGS14")
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50, debug = T,
bugs.directory = "C:/Users/Weng Lab/Downloads/winbugs143_unrestricted/winbugs14_full_patched/WinBUGS14")
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}
}
dim(dt)[1]
dt
dim(dt)
class(dt)
## We know the maximum number of times a single fish was recaptured from the structure of our dataset
max_recaptures = 4
## Preallocating data objects in memory
n = rep(0, length(mark_recapture_data$tag_id))
L = matrix(nrow = length(mark_recapture_data$tag_id), ncol = (max_recaptures + 1), data = NA) # Note that matrix L gets an extra column corrosponding to initial fork length at tagging
dt = matrix(nrow = length(mark_recapture_data$tag_id), ncol = max_recaptures, data = NA) # Note that because dt is the difference in time, therefore it is one column less than L
for(i in 1:length(mark_recapture_data$tag_id)){
## For each individual, we start at the intial length at tagging and work our way up through recaptures
L[i,1] = as.numeric(mark_recapture_data$fork_length_in[i])
## Recapture 1
if(!is.na(mark_recapture_data$recapture_1_fork_length_cm[i])){
## Calculate differece in time and if its greater than 60 days
dt1 = difftime(mark_recapture_data$recapture_1_date[i], mark_recapture_data$tag_date[i], units = 'days') / 365
if(all(!is.na(dt1) & dt1 > 60/365)){
# Updating vector n
n[i] = n[i] + 1
# Getting recorded fork length
L[i, 2] = as.numeric(mark_recapture_data$recapture_1_fork_length_cm[i])
# Calculating time at liberty
dt[i, 1] = as.numeric(dt1)
}
}
### Repeat the above for subsequent recaptures
## Recapture 2
if(!is.na(mark_recapture_data$recapture_2_fork_length_cm[i])){
dt2 = difftime(mark_recapture_data$recapture_2_date[i], mark_recapture_data$tag_date[i], units = 'days') / 36
if(all(!is.na(dt2) & dt2 > 60/365)){
n[i] = 2
L[i, 3] = as.numeric(mark_recapture_data$recapture_2_fork_length_cm[i])
dt[i, 2] = as.numeric(dt2)
}
}
## Recapture 3
if(!is.na(mark_recapture_data$recapture_3_fork_length_cm[i])){
dt3 = difftime(mark_recapture_data$recapture_3_date[i], mark_recapture_data$tag_date[i], units = 'days') / 365
if(all(!is.na(dt3) & dt3 > 60/365)){
n[i] = 3
L[i, 4] = as.numeric(mark_recapture_data$recapture_3_fork_length_cm[i])
dt[i, 3] = as.numeric(dt3)
}
}
if(!is.na(mark_recapture_data$recapture_4_fork_length_cm[i])){
dt4 = difftime(mark_recapture_data$recapture_4_date[i], mark_recapture_data$tag_date[i], units = 'days') / 365
if(all(!is.na(dt4) & dt4 > 60/365)){
n[i] = 4
L[i, 5] = as.numeric(mark_recapture_data$recapture_4_fork_length_cm[i])
dt[i,4] = as.numeric(dt4)
}
}
}
### L and dt matricies need to be adjusted for fish recaptured more than once but for whom one of their recaptures was excluded for being less than our 60 day threshold
## Set up vector indexing which fish to remove after our loop.We will remove fish that have no recaptures after 60 days a liberty.
valid_recaps = rep(TRUE, dim(dt)[1])
## Loop through each fish
for(i in 1:dim(dt)[1]){
# If the first column of NAs does not come after the last column of data or if the whole row isn't NAs
while(!all(is.na(dt[i, ])) && (!max(which(!is.na(dt[i, ]))) < min(which(is.na(dt[i, ]))))){
# We shift all our data after the NA over by one and try again
L[i, (1 + min(which(is.na(dt[i, ])))):ncol(dt)] =  c(L[i, (1 + (min(which(is.na(dt[i, ]))))+ 1):ncol(dt)], NA)
dt[i, min(which(is.na(dt[i, ]))):ncol(dt)] =  c(dt[i, (min(which(is.na(dt[i, ]))) + 1):ncol(dt)], NA)
}
if(all(is.na(dt[i, ]))){
valid_recaps[i] = FALSE
}
}
## Removing fish without valid recaptures
dt = dt[valid_recaps, ]
L = L[valid_recaps, ]
n = n[valid_recaps]
mark_recap_data = list('n', 'L', 'dt')
# Loop through individual fish
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}}
L.pred
L.pred = L
L_Exp = L
p.value = L
# Loop through individual fish
for (i in 1:dim(dt)[1])	 {
# loop through each subsequent recapture
for(j in (1:n[i])+1){
## Calculate expected length for each recaptures
L[i, j] ~ dnorm(L_Exp[i, j], tau)
L_Exp[i, j] <-  Linf[i] *(1.0 - exp(-k[i]*(A[i]+dt[i, j-1])))
L.pred[i, j] ~ dnorm(L_Exp[i, j], tau)
p.value[i, j] <- step(L.pred[i, j] - L[i, j])
}}
L[i,j]
dnorm(L_Exp[i, j], tau)
tau
dt
## Run Models
model_1 = bugs(data = mark_recap_data, inits = inits,
model.file = file.path(src_dir,'Bayes/model1upd.txt'),
# parameters = c('Linf_std', 'k_std', 'var', 'Linf_mu', 'Linf_tau', 'shape', 'rate', 'k_mu', 'k_tau', 'tau'),
parameters.to.save =  c('Linf_mu', 'Linf_std', 'k_mu', 'k_std'),
DIC = T,
n.chains = 3, n.iter = 500000, n.burnin = 10000, n.thin = 50, debug = T,
bugs.directory = "C:/Users/Weng Lab/Downloads/winbugs143_unrestricted/winbugs14_full_patched/WinBUGS14")
n[i]
n[i]
dt[i, 2-1]
